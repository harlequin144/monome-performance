
// THink about merging some of the press counters. try to prevent accidntal
// hits... Will have to keep keys and control section separate tho..

Micronome {

	//classvar numMicronomes;
	const path = "/sc/micronome";
	const lPath = "/sc/micronome/grid/led";

	// State
	var show = false;
	var hold = false;
	var transPressCount = 0;
	var seqPressCount = 0;

	// Notes
	var pitchRange = 12;
	var noteStack; // This keeps track of what is being pressed on the monome
	var notesOn; // This keeps track of noteons that have been sent
	//var topNote = 60; // Note currently being played.
	//var keyPressCount = 0;

	//Sequencer
	var seq;
	var seqState = 0; //0 off, 1 recording, and else is playing
	var selectedSeq = 0; // thru 3
	var seqPos = 0;
	var recordSilently = true;
	var seqPlaySpeed = 0;

	// Osc/Midi
	var monome, bridge;
	var midiOut; // Keeps track of what notes are on microbrute-side


	*new {|midiUid, bridgePortNum = 8000, monomePortNum = 13090|
		^super.new.init(midiUid, bridgePortNum, monomePortNum)
	}

	init {|midiUid, bridgePortNum = 8000, monomePortNum = 13090|
		bridge = NetAddr.new("localhost", bridgePortNum);
		monome = NetAddr.new("localhost", monomePortNum);
		midiOut = MIDIOut(0, midiUid);
		midiOut.latency = 0;

		// Data Structure Initialization
		noteStack = LinkedList[];
		notesOn = Set[];
 		seq = Array[
			LinkedList[60],LinkedList[60],LinkedList[60],LinkedList[60] ];
		midiOut.control(0,105, 127);  // Seq Play hold to off
		midiOut.sysex(Int8Array[16rB0, 16r65, 16r0, 16rB0, 16r64, 16r0,
			16rB0, 16r06, pitchRange]);

		// Osc Responder Registration
		OSCdef(\micronome_press,
			{|msg, time|
				if(msg[3] == 1)
				{ this.pressResponder(msg[1], msg[2], time) }
				{ this.releaseResponder(msg[1], msg[2]) }
			},
			path +/+ 'grid/key');

		OSCdef(\micronome_hide, { show = false; }, path+/+'hide');
		OSCdef(\micronome_tick, {|msg| this.tickResponder(msg[1]) }, '/tick');
		OSCdef(\micronome_show, { show = true; this.show },
			path+/+'show');

		this.show();
	}

	/*
	 * Press Functions
	 */

	pressResponder {|xPos, yPos, time|
		show = true;
		case
		//Mod or key press
		{ xPos >= 4 }{
			if(yPos == 0)
			{ this.modPress(xPos-3) }
			{ this.notePress(xPos, yPos) }
		}

		// Exit and toggle trans
		{ yPos == 0 }{
			if(xPos < 2)
			{ this.hide }
			{ this.transToggle } // On Off
		}

		// Tap and Clear
		{ (yPos == 1) || (yPos == 2) }
		{ this.clearTapPress(xPos, time) }

		// Record and Play
		{ (yPos == 3) || (yPos == 4) }{
			if(xPos < 2)
			{ this.recordPress }
			{ this.playPress }
		}
		// Pattern Select
		{ yPos == 5 }
		{ this.selectPress(xPos) }

		// Pattern Note Play Speed
		{ yPos == 6 }
		{ this.seqPlaySpeedPress(xPos) }

		// Hold
		{ yPos == 7 }
		{ this.holdToggle() }
	}


	// Press helpers

	releaseResponder {|xPos, yPos|
		case
		// Key Release
		{ (xPos >= 4) && (yPos >= 1) }{
			var note = (12*yPos) + (xPos-4);

			case
			{seqState > 1}
			{ this.noteOff(topNote + seq[selectedSeq][seqPos]) }

			{ (seqState == 0) || (seqState == 1)}
			{
				if(hold){
					"in hold is true".postln;
					this.killNotesOn();
					case
					{ noteStack.size == 1 }
					{ noteStack.remove(note); midiOut.noteOn(0, note); }
					{ noteStack.size > 1 }
					{ midiOut.noteOn(0, noteStack.last())};

				}{
					"in hold is false".postln;
					this.killNotesOn();
					noteStack.remove(note);
					if(noteStack.size != 0){
						midiOut.noteOn(0, noteStack.last());
						("note on in release: " ++ noteStack.last());
					};
				}
			}

		}
		// Transport Release
		{ ((yPos == 0) && (xPos > 1)) || (yPos == 1) || (yPos == 2) }{
			transPressCount = transPressCount - 1;
			if(transPressCount < 0){ transPressCount = 0 }
		}
		// Pattern Select and Play and Record
		{ (yPos == 3) || (yPos == 4) || (yPos == 5) }{
			seqPressCount = seqPressCount - 1;
			if(seqPressCount < 0){ seqPressCount = 0 };
			//seqPressCount.postln;
		}
	}

	clearTapPress {|xPos, time|
		transPressCount = transPressCount + 1;
		if(transPressCount == 1){
			if(xPos < 2)
			{ ~trans.clear_tap } // Clear
			{
				~trans.tap(time);
				if(~trans.on){
					monome.sendMsg( lPath+/+"set", 2,0,1);
					monome.sendMsg( lPath+/+"set", 3,0,1);
				}
			}
		}
	}

	playPress {
		seqPressCount = seqPressCount + 1;
		if(seqPressCount == 1){

			if(seqState == 2){ // Already on, turn off
				seqState = 0;
				monome.sendMsg( lPath+/+"row",0, 3, 80, 171);
				monome.sendMsg( lPath+/+"row",0, 4, 80, 171);
				this.killNotesOn();
				//noteStack = LinkedList[];
			}
			{ // was off or recording, turn on
				seqState = 2;
				monome.sendMsg( lPath+/+"row",0,3, 92, 171);
				monome.sendMsg( lPath+/+"row",0,4, 92, 171);
			}
		};
		seqPos = 0;
	}

	recordPress {
		seqPressCount = seqPressCount + 1;
		if(seqPressCount == 1){
			if(seqState == 1) // Seq is in record mode
			{	// Pressing it again will put it in silent record mode
				if(recordSilently){ // turn recording off
					recordSilently = false;
					seqState = 0;
					monome.sendMsg( lPath+/+"row",0,3, 80, 171);
					monome.sendMsg( lPath+/+"row",0,4, 80, 171);
				}{
					recordSilently = true;
					monome.sendMsg( lPath+/+"row",0,3, 81, 171);
					monome.sendMsg( lPath+/+"row",0,4, 82, 171);
				}
			}
			{	// Seq is off or in play mode
				seqState = 1; // turn on seq in record mode
				recordSilently = false; // first press keeps it audible
				monome.sendMsg( lPath+/+"row",0,3, 83, 171);
				monome.sendMsg( lPath+/+"row",0,4, 83, 171);
			}
		};
		seqState.postln;
		recordSilently.postln;
		seqPos = 0;
	}

	selectPress {|xPos|
		if((xPos >= 0 ) && ( xPos <= 3)){
			var newSelected = xPos;
			if( selectedSeq != newSelected ){
				selectedSeq = newSelected;
				monome.sendMsg( lPath+/+"row",0,5, 80 + (2**selectedSeq), 171);
			}
		};
		seqPos = 0;
	}

	notePress { |xPos, yPos| //|time|
		var note = (12*yPos) + (xPos-4);
		//keyPressCount = keyPressCount + 1;
		if(hold){ this.noteOff(topNote) };

		case
		{ seqState == 0 }{ 	//free mode
			//if(hold){ this.noteOff(topNote) };
			//topNote = note;
			//midiOut.noteOn(0, note);
			//noteStack.add(note);
			//if(noteStack.size != 0){ midiOut.noteOff(0, noteStack.last()) };
			this.killNotesOn();
			noteStack.postln;
			noteStack.add(note);
			("note on in press: " ++ note).postln;
			midiOut.noteOn(0, note);
			noteStack.postln;
		}
		{ seqState == 1 }{ // record mode
			if(hold){ this.noteOff(topNote) };
			if(recordSilently == false){
				midiOut.noteOn(0, note);
				noteStack.add(note);
			};
			if(seqPos == 0){
				seq[selectedSeq] = LinkedList[topNote];
				seqPos = seqPos + 1;
			}{
				seq[selectedSeq].add( topNote - seq[selectedSeq].first );
				seqPos = seqPos + 1;
			};
		}
		{ (seqState > 1) && (~trans.on == false) }
		{
			topNote = note + seq[selectedSeq][seqPos];
			midiOut.noteOn(0, topNote);
			noteStack.add(topNote);
		}
	}

	seqPlaySpeedPress {|xPos|
		if((xPos >=0) && (xPos <= 3)){
			seqPlaySpeed = xPos;
			monome.sendMsg( lPath+/+"row", 0,6, 2**xPos, 0);
		}
	}

	transToggle {
		transPressCount = transPressCount + 1;
		if(transPressCount == 1){
			if( ~trans.on ){
				~trans.stop;
				monome.sendMsg(lPath +/+ "set", 2,0,0);
				monome.sendMsg(lPath +/+ "set", 3,0,0);
				monome.sendMsg(lPath +/+ "row",0,1, 80,171);
				monome.sendMsg(lPath +/+ "row",0,2, 0);
				if(seqState == 2){
					this.killNotesOn();
					if(noteStack.size != 0)
					//{ noteStack = LinkedList[] }
					{ noteStack = LinkedList[topNote]; midiOut.noteOn(0, topNote) }
				};
			}{
				~trans.start;
				monome.sendMsg(lPath +/+ "set", 2,0,1);
				monome.sendMsg(lPath +/+ "set", 3,0,1);
			}
		}
	}


	modPress { |val|
		// enter the value that you want it to be changed to.
		var side = (val<4);
		if((val >= 0) && (val <= 12)){
			pitchRange = val;
			midiOut.sysex(Int8Array[16rB0, 16r65, 16r0, 16rB0, 16r64, 16r0,
				16rB0, 16r06, val]);
			monome.sendMsg(lPath +/+ "row", 0,0,
				side.if{ 1+(16*((2**val) -1 )) }{ 241 },
				side.if{ 0 }{ 2**(val-4)-1} );
		}
	}

	/*
	 * Other Functions
	 */

	holdToggle {
		if(hold == true) {
			hold = false;
			if(noteStack.size > 0){
				this.killNotesOn();
				while( {noteStack.size > 0}, {noteStack.popFirst()} );
				midiOut.noteOn(0, noteStack.last());
			}
		}{
			hold = true;
			//noteStack.do({|note|
			//	if(note != topNote){ midiOut.noteOff(0, note) }
			//});
			//	noteStack = LinkedList[topNote];
		};
		monome.sendMsg(lPath +/+ "row", 0,7,hold.if{12}{3}+80, 171);
	}

	show {
		var seqFact = if(seqState == 2){3}{seqState};
		var pitchG4 = (pitchRange >=5 );
		var selState = (selectedSeq <2);
		// Left side
		monome.sendMsg(lPath +/+ "map", 0,0,
			( pitchG4.if{241}{ 1+(16*((2**pitchRange)-1)) } ) +
			( if(~trans.on){12}{0} ),
			80, 0, // Tap and clear - let tick handle update this
			80 + (4*seqFact), // Play and Record
			80 + (4*seqFact),
			80 + (2** selectedSeq), // Select Seq
			2**seqPlaySpeed,//Playback speed
			83 + (9*hold.if{1}{0}) // Hold
		);
		// Right Side
		monome.sendMsg(lPath +/+ "map",8,0,
			(pitchG4).if{ 2**(pitchRange-4)-1 }{0},
			171,0,171,171,171,0,171);
	}

	hide{
		show = false;
		bridge.sendMsg("/bridge/show");
		//keyPressCount = 0;
		transPressCount = 0;
		seqPressCount = 0;
		if(seqState > 1){ this.killNotesOn() };
	}

	tickResponder {|tick|
		var speed = 12; //(3 * (2**(4-seqPlaySpeed)));
		case
		{ seqPlaySpeed == 0 }{ speed = 12 }
		{ seqPlaySpeed == 1 }{ speed = 6 }
		{ seqPlaySpeed == 2 }{ speed = 3 }
		{ seqPlaySpeed == 3 }{ speed = 8 };

		if((seqState==2)&&(hold || ((hold == false)&&(noteStack.size != 0))) ){
			if((tick/speed)%4 == 0){ // Down
				var note = if(seqPos == 0)
					{topNote}
					{topNote + seq[selectedSeq][seqPos]};
				this.killNotesOn();
				midiOut.noteOn(0, note);
				noteStack.add(note);
				seqPos = (seqPos + 1)%seq[selectedSeq].size;
			};
		};

		if((seqState==2)){
			if((tick/speed)%4 == 3){ // Up
				this.killNotesOn();
			};
		};

		if(show){
			case
			{tick%48 == 0}{
				monome.sendMsg(lPath +/+ "row",0,1, 83,171);
				monome.sendMsg(lPath +/+ "row",0,2, 3,0);
			}
			{tick%48 == 24}{
				monome.sendMsg(lPath +/+ "row",0,1, 92,171);
				monome.sendMsg(lPath +/+ "row",0,2, 12,0);
			}
		}
	}

	/*
	 * Note Management
	 */
	noteOn {|num| 
		midiOut.noteOn(0, num);
		notesOn.add(num);

	noteOff {|num|
		midiOut.noteOff(0, num);
		notesOn.remove(num);
		//noteStack.remove(num);
	}

	killNotesOn { notesOn.do(
		{|note|
			this.noteOff(note);
			("killing note: " + note).postln;
		})
	}

	killallnotes {
		(1..100).do({|note| midiOut.noteOff(0, note) })
	}
}
